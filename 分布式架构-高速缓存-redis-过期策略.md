## redis过期策略

1. 设置过期时间

    * expire key time(以秒为单位)--这是最常用的方式
    * setex(String key, int seconds, String value)--字符串独有的方式

    注意：

    * 除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间
    * 如果没有设置时间，那缓存就是永不过期
    * 如果设置了过期时间，之后又想让缓存永不过期，使用persist key
 

2. 三种过期策略

    * 定时删除
        * 含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除
        * 优点：保证内存被尽快释放
        * 缺点：
            * 若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key
            * 定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重
            * 没人用
    * **惰性删除**
        * 含义：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。
        * 优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）
        * 缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）
    * **定期删除**
        * 含义：每隔一段时间执行一次删除过期key操作
        * 优点：
            * 通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用--处理"定时删除"的缺点
            * 定期删除过期key--处理"惰性删除"的缺点
        * 缺点
            * 在内存友好方面，不如"定时删除"
            * 在CPU时间友好方面，不如"惰性删除"
        * 难点
            * 合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了）
    
    注意：

    * 上边所说的数据库指的是内存数据库，默认情况下每一台redis服务器有16个数据库（关于数据库的设置，看下边代码），默认使用0号数据库，所有的操作都是对0号数据库的操作，关于redis数据库的存储结构，查看 第八章 Redis数据库结构与读写原理

        ```
        # 设置数据库数量。默认为16个库，默认使用DB 0，可以使用"select 1"来选择一号数据库
        # 注意：由于默认使用0号数据库，那么我们所做的所有的缓存操作都存在0号数据库上，
        # 当你在1号数据库上去查找的时候，就查不到之前set过得缓存
        # 若想将0号数据库上的缓存移动到1号数据库，可以使用"move key 1"
        databases 16
        ```
    
    * *memcached只是用了惰性删除，而redis同时使用了惰性删除与定期删除*，这也是二者的一个不同点（可以看做是redis优于memcached的一点）
    * *对于惰性删除而言，并不是只有获取key的时候才会检查key是否过期，在某些设置key的方法上也会检查*（eg.setnx key2 value2：该方法类似于memcached的add方法，如果设置的key2已经存在，那么该方法返回false，什么都不做；如果设置的key2不存在，那么该方法设置缓存key2-value2。假设调用此方法的时候，发现redis中已经存在了key2，但是该key2已经过期了，如果此时不执行删除操作的话，setnx方法将会直接返回false，也就是说此时并没有重新设置key2-value2成功，所以对于一定要在setnx执行之前，对key2进行过期检查）
    

3. Redis采用的过期策略

    **惰性删除+定期删除**

    * 惰性删除流程
        * 在进行get或setnx等操作时，先检查key是否过期，
        * 若过期，删除key，然后执行相应操作；
        * 若没过期，直接执行相应操作

    * 定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）
        * 遍历每个数据库（就是redis.conf中配置的"database"数量，默认为16）
            * 检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）
                * 如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历
                * 随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key
                * 判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。
    注意：

    * 对于定期删除，在程序中有一个全局变量current_db来记录下一个将要遍历的库，假设有16个库，我们这一次定期删除遍历了10个，那此时的current_db就是11，下一次定期删除就从第11个库开始遍历，假设current_db等于15了，那么之后遍历就再从0号库开始（此时current_db==0）
    * *由于在实际中并没有操作过定期删除的时长和频率，所以这两个值的设置方式作为疑问？*
    

 4. RDB对过期key的处理

    过期key对RDB没有任何影响

    * 从内存数据库持久化数据到RDB文件
        * 持久化key之前，会检查是否过期，过期的key不进入RDB文件
    * 从RDB文件恢复数据到内存数据库
        * 数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）
    

5. AOF对过期key的处理

    过期key对AOF没有任何影响

    * 从内存数据库持久化数据到AOF文件：
        * 当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）
        * 当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）
    * AOF重写
        * 重写时，会先判断key是否过期，已过期的key不会重写到aof文件 

原文：https://www.cnblogs.com/java-zhao/p/5205771.html