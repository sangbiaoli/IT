1. 运行时数据区域
    * 程序计数器：当前线程所执行的字节码的行号指示器
    * Java虚拟机栈：方法执行的时候创建的栈帧，用于存储局部变量表，操作栈，动态链接，方法出口等信息
    * 本地方法栈：跟Java虚拟机栈非常相似，区别是虚拟机栈为虚拟机执行Java方法服务，本地方法栈则是为虚拟机使用的Native方法服务。
    * Java堆（Heap）：被所有线程共享的一块内存区域，存放对象实例
    * 方法区（Non-Heap）：各个线程共享的内存区域，存储已被虚拟机加载的类信息、常量、静态变量，即时编译器编译后的代码等数据
        * 运行时常量池：用于存放编译器生成的各种字面量和符号引用

    线程私有：程序计数器，Java虚拟机栈

2. 垃圾收集算法
    1. 标记-清除算法：碎片多
    2. 复制算法：A和B大小一样，把A中存活的对象copy到B,清理A，内存缩一半
       回收新生代算法：按照比例划分三块，Eden:Survivor0:Survivor1=8:1:1，每次使用Eden和Survivor0，回收时，把Eden和Survivor0的存活对象copy到Survivor1，清理Eden和Survivor0。
    3. 标记-整理算法:让所有存活对象向一端移动，然后清理掉段边界以外的内存
    4. 分代收集算法：划分新生代和老生代，新生代用“复制”算法，老生代用“标记-清理”和“标记-整理”算法


3. 垃圾收集器
    1. Serial收集器：单线程的新生代收集器，进行收集时，必须暂停其他所有的的工作线程，由虚拟机在后台自动发起和自动完成。对于运行在Client模式下的虚拟机是一个很好的选择。
    2. ParNew收集器：Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为与Serial收集器一样。是运行在Server模式下的虚拟机中首选的新生代收集器。
    3. Parallel Scavenge收集器：新生代收集器，使用复制算法且并行的多线程收集器，目标是达到一个可控制的吞吐量（垃圾收集时间/虚拟机运行时间）。适合在后台运算而不需要太多交互的任务。
    4. Serial Old收集器：Serial收集器的老年代版本，使用“标记-整理”算法，被Client模式下的虚拟机使用。
    5. Parallel Old收集器：Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法
    6. CMS收集器：一种以获取最短回收停顿时间为目标的收集器，基于“标记-清除算法”，尤其重视服务的响应速度。
        缺点：1. 对CPU资源非常敏感 2. 无法处理浮动垃圾 3. 收集结束时会产生大量空间碎片。
    7. G1收集器：一是基于“标记-整理”的算法，二是可以非常精准的控制停顿。G1将整个Java对划分多个大小固定的独立区域，根据堆积程度维护优先列表。

4. 内存分配与回收策略
    Minor GC：新生代GC
    Major GC/Full GC:老年代GC

    1. 对象优先在Eden分配
        举例：
        新生代(10M)：Eden(8M),Survivor1(1M),Survivor2(1M)
        老年代(10M)
        依次要分配的是2M，2M，2M，4M。
        1. 2M + 2M + 2M分配在Eden中
        2. 4M无法分配在Eden中，发生Minor GC，结果6M无法分在Survivor2中，因此提前转移到老年代
        3. 而后4M可以分配在Eden中。
        因此分配后对象占用的结果就是：Eden(4M)，老年代（6M）

    2. 大对象直接进入老年代
        所谓大对象是指，需要大量连续内存空间的Java对象

    3. 长期存活的对象将进入老年代
        对象年龄计数器，每次GC还存活，则年龄加1，15（默认值）次后转移到老年代

    4. 动态对象年龄判断
        在Survivor空间中相同年龄所有对象大小总和大于Suvivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。

    5. 空间分配担保
        发生Minor GC时，虚拟机检测每次晋升到老年代的平均大小是否大于老年代的剩余空间大小
            如果大于，则Full GC
            如果小于，
                如果允许担保失败，则Minor GC
                否则 Full GC
            
