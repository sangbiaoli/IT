## 设计模式

设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。本文将介绍23种设计模式。

在阅读完极客的文章后，个人简略下做下笔记，方便记忆：

* 创建类模式
    * 单例模式：A只有一个实例，饿汉式（直接初始化）和懒汉式（等用时初始化）
    * 工厂方法模式：工厂和产品都是接口，两者都有实现类
    * 抽象工厂模式：工厂接口可以生产不同的产品（所以存在不同产品的接口）
    * 建造者模式：肯德基的一餐，每种食品Item都有名称，价格，打包方式（接口，两个实现类：瓶装，袋装），构造一餐时，只需要传递Item列表，就可以算出一餐的价格并可以打印每种食品详情。食品构造时，分成瓶装和袋装抽象出两大类。
    * 原型模式：主要实现clone方法，快速clone对象

* 行为类模式
    * 模板方法模式：抽象类，假如一个功能的实现要执行几个方法(A,B,C)，其中A,C已经实现，B是抽象方法，然后让别人去实现B
    * 中介者模式：同事之间是网状结构，A的动作会影响B，改造成星状结构，A执行完自己的动作后，有中介处理A，B的事
    * 观察者模式：被观察者A有一个观察者列表（B,C），当A做动作时，循环观察者，让其执行自己的方法
    * 访问者模式：定义Element接口接收Visitor接口，定义Visitor接口针对不同的Element做出访问的动作。在实现不同的Element和Visitor即可。
    * 命令模式：定义一个Command接口，Invoker内置Command，其内部的操作会用到Commmand，定义一个Command实现类，内置Receiver，Command的方法由Receiver完成。
    * 责任链模式：定义抽象Handler，并内置nextHandler，根据传进来的request，请求条件满足则自己处理否则交由nextHandler处理，实现不同的Handler,并组装责任链。
    * 策略模式：Context内置Strategy接口，定义方法调用Strategy接口，实现不同的Strategy接口，所有动作有Context发起。
    * 迭代器模式：自定义Iterator，内置列表存储元素，实现Iterator接口，再自定义集合，该集合内置该Iterator
    * 解释器模式：代码不完整，且不常用
    * 备忘录模式：Originator，Memento都内置state，初始化Originator的state后，Originator根据state构造Memento交由Caretaker保管，然后Originator可以改变state后可从Caretaker复原。
    * 状态模式:定义类包含一个接口，状态改变时，接口的实现类也变了或某个方法里面，根据状态值做不同的操作。

* 结构型模式
    * 适配器模式：存在客户接口IOrigin(方法没参数)，重新定义ITarget(方法带参数)，实现ITarget时，根据参数值判断，调用IOrigin接口
    * 装饰器模式：已有接口ICar和实现类Car，要为Car的接口添加操作，新建的类不用extends Car，用implments ICar，并内置Car，实现接口时，直接用内置的car方法在加上新的操作
    * 代理模式：已有接口Subject和实现RealSubject，代理类Proxy内置RealSubject并implements Subject，重写方法时在调用RealSubject的实现，怎么感觉跟装饰者很相似呢?
    * 外观模式:完成一个操作由A，B，C的不同操作完成，则定义类，内置A，B, C，该操作分别由A，B，C执行自己的方法
    * 桥接模式：定义一个接口I，并有实现A，B，定义类C，内置I，C初始设置I为A，并做事，后设置I为B，再做事。
    * 组合模式：结构递归，像树的节点，节点有子节点，然后每个节点有自己处理的方式
    * 享元模式：定义一个类，内置map存储不同类型的数据，需要获取时，判断map中是否存在，存在直接返回，不存在则创建，放入到map，再返回。

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
